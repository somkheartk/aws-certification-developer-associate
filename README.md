# AWS Certified Developer - Associate Tutorial (Tutorial ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏≠‡∏ö AWS Developer Associate)

‡∏Ñ‡∏π‡πà‡∏°‡∏∑‡∏≠‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏™‡∏≠‡∏ö AWS Certified Developer - Associate ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏Ñ‡∏£‡∏ö‡∏ñ‡πâ‡∏ß‡∏ô

## üöÄ Quick Start
**New to this certification?** Start with the [Getting Started Guide](GETTING_STARTED.md) for a step-by-step approach!

## üìã Table of Contents
- [‡∏†‡∏≤‡∏û‡∏£‡∏ß‡∏°‡∏Å‡∏≤‡∏£‡∏™‡∏≠‡∏ö (Exam Overview)](#exam-overview)
- [‡πÇ‡∏î‡πÄ‡∏°‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡∏≠‡∏ö (Exam Domains)](#exam-domains)
- [1. Development with AWS Services (32%)](#1-development-with-aws-services)
- [2. Security (26%)](#2-security)
- [3. Deployment (24%)](#3-deployment)
- [4. Troubleshooting and Optimization (18%)](#4-troubleshooting-and-optimization)
- [‡πÅ‡∏´‡∏•‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏° (Additional Resources)](#additional-resources)
- [‡πÄ‡∏Ñ‡∏•‡πá‡∏î‡∏•‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏™‡∏≠‡∏ö (Exam Tips)](#exam-tips)

## üìö Additional Study Materials
- **[Study Checklist](STUDY_CHECKLIST.md)** - Track your learning progress
- **[Quick Reference Guide](QUICK_REFERENCE.md)** - Service limits, CLI commands, and decision trees
- **[Practice Questions](PRACTICE_QUESTIONS.md)** - 25+ practice questions with explanations
- **[Resources](RESOURCES.md)** - Comprehensive list of courses, books, and study materials
- **[Hands-on Workshops](WORKSHOPS.md)** - üÜï Practical labs and step-by-step tutorials

---

## Exam Overview

### ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡∏™‡∏≠‡∏ö (Exam Information)
- **‡∏£‡∏∞‡∏¢‡∏∞‡πÄ‡∏ß‡∏•‡∏≤ (Duration):** 130 ‡∏ô‡∏≤‡∏ó‡∏µ
- **‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö (Format):** ‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡πÅ‡∏ö‡∏ö‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ï‡∏≠‡∏ö (Multiple choice ‡πÅ‡∏•‡∏∞ Multiple response)
- **‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ç‡πâ‡∏≠ (Number of Questions):** 65 ‡∏Ç‡πâ‡∏≠
- **‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡∏ú‡πà‡∏≤‡∏ô (Passing Score):** 720/1000
- **‡∏£‡∏≤‡∏Ñ‡∏≤ (Cost):** $150 USD
- **‡∏†‡∏≤‡∏©‡∏≤ (Languages):** ‡∏≠‡∏±‡∏á‡∏Å‡∏§‡∏©, ‡∏ç‡∏µ‡πà‡∏õ‡∏∏‡πà‡∏ô, ‡πÄ‡∏Å‡∏≤‡∏´‡∏•‡∏µ, ‡∏à‡∏µ‡∏ô‡∏Å‡∏•‡∏≤‡∏á (‡∏ï‡∏±‡∏ß‡∏¢‡πà‡∏≠)

### ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏£‡∏π‡πâ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ (Prerequisites)
- ‡∏õ‡∏£‡∏∞‡∏™‡∏ö‡∏Å‡∏≤‡∏£‡∏ì‡πå‡∏Å‡∏≤‡∏£‡∏û‡∏±‡∏í‡∏ô‡∏≤‡πÅ‡∏•‡∏∞‡∏ö‡∏≥‡∏£‡∏∏‡∏á‡∏£‡∏±‡∏Å‡∏©‡∏≤‡πÅ‡∏≠‡∏õ‡∏û‡∏•‡∏¥‡πÄ‡∏Ñ‡∏ä‡∏±‡∏ô‡∏ö‡∏ô AWS ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ 1 ‡∏õ‡∏µ
- ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏£‡∏π‡πâ‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Å‡∏±‡∏ö AWS service ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ 1 ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£
- ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÇ‡∏Ñ‡πâ‡∏î‡∏î‡πâ‡∏ß‡∏¢‡∏†‡∏≤‡∏©‡∏≤‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏™‡∏π‡∏á (High-level programming language)
- ‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à‡πÉ‡∏ô‡πÅ‡∏ô‡∏ß‡∏Ñ‡∏¥‡∏î‡∏´‡∏•‡∏±‡∏Å‡∏Ç‡∏≠‡∏á AWS ‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ AWS CLI, SDKs, ‡πÅ‡∏•‡∏∞ APIs

---

## Exam Domains

‡∏Å‡∏≤‡∏£‡∏™‡∏≠‡∏ö‡πÅ‡∏ö‡πà‡∏á‡∏≠‡∏≠‡∏Å‡πÄ‡∏õ‡πá‡∏ô 4 ‡πÇ‡∏î‡πÄ‡∏°‡∏ô‡∏´‡∏•‡∏±‡∏Å:

1. **Development with AWS Services** - 32%
2. **Security** - 26%
3. **Deployment** - 24%
4. **Troubleshooting and Optimization** - 18%

---

## 1. Development with AWS Services

### 1.1 AWS Lambda
**‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏π‡πâ:**
- Lambda function lifecycle ‡πÅ‡∏•‡∏∞ execution context
- Event source mappings ‡πÅ‡∏•‡∏∞ triggers
- Lambda layers ‡πÅ‡∏•‡∏∞ environment variables
- Concurrency ‡πÅ‡∏•‡∏∞ throttling
- Cold starts ‡πÅ‡∏•‡∏∞ warm starts
- ‡∏Ç‡∏µ‡∏î‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏Ç‡∏≠‡∏á Lambda (Timeout: 15 ‡∏ô‡∏≤‡∏ó‡∏µ, Memory: 128 MB - 10 GB)

**‡πÅ‡∏ô‡∏ß‡∏ó‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô:**
```python
import json
import boto3

# Initialize AWS clients outside handler for connection reuse
dynamodb = boto3.resource('dynamodb')
s3 = boto3.client('s3')

def lambda_handler(event, context):
    # ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏• event
    body = json.loads(event['body'])
    
    # Business logic
    result = process_data(body)
    
    return {
        'statusCode': 200,
        'headers': {
            'Access-Control-Allow-Origin': '*',
            'Content-Type': 'application/json'
        },
        'body': json.dumps(result)
    }

def process_data(data):
    # Example: Save to DynamoDB
    table = dynamodb.Table('MyTable')
    table.put_item(Item=data)
    return {'message': 'Data saved successfully'}
```

**Real-world Examples:**

**Example 1: Image Resizer**
```python
import json
import boto3
from PIL import Image
from io import BytesIO

s3 = boto3.client('s3')

def lambda_handler(event, context):
    # Get S3 event
    bucket = event['Records'][0]['s3']['bucket']['name']
    key = event['Records'][0]['s3']['object']['key']
    
    # Download image
    obj = s3.get_object(Bucket=bucket, Key=key)
    img = Image.open(BytesIO(obj['Body'].read()))
    
    # Resize
    img.thumbnail((300, 300))
    
    # Upload back to S3
    buffer = BytesIO()
    img.save(buffer, 'JPEG')
    buffer.seek(0)
    
    s3.put_object(
        Bucket=bucket,
        Key=f'thumbnails/{key}',
        Body=buffer,
        ContentType='image/jpeg'
    )
    
    return {'statusCode': 200}
```

**Example 2: Data Enrichment**
```python
import json
import boto3
import requests

dynamodb = boto3.resource('dynamodb')

def lambda_handler(event, context):
    # SQS event
    for record in event['Records']:
        message = json.loads(record['body'])
        user_id = message['userId']
        
        # Enrich data from external API
        response = requests.get(f'https://api.example.com/users/{user_id}')
        user_data = response.json()
        
        # Save enriched data
        table = dynamodb.Table('EnrichedUsers')
        table.put_item(
            Item={
                'userId': user_id,
                'name': user_data['name'],
                'email': user_data['email'],
                'metadata': message
            }
        )
    
    return {'statusCode': 200}
```

**Lambda Best Practices:**
1. **Connection Pooling**: Initialize clients outside handler
2. **Environment Variables**: Use for configuration
3. **Layers**: Share code across functions
4. **Error Handling**: Always use try-catch
5. **Timeouts**: Set appropriate timeout values
6. **Memory**: More memory = more CPU
7. **Cold Start**: Keep deployment package small
8. **Async**: Use async for long-running tasks

### 1.2 Amazon API Gateway
**‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏π‡πâ:**
- REST APIs vs HTTP APIs vs WebSocket APIs
- API Gateway stages ‡πÅ‡∏•‡∏∞ deployment
- Request/Response transformations
- API throttling ‡πÅ‡∏•‡∏∞ rate limiting
- API Gateway caching
- Integration types: Lambda, HTTP, AWS Service, Mock

**Best Practices:**
- ‡πÉ‡∏ä‡πâ API keys ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö authentication
- Enable caching ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏•‡∏î latency
- Configure throttling ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô abuse
- ‡πÉ‡∏ä‡πâ stages ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö development, staging, production

**API Gateway Examples:**

**Example 1: Lambda Proxy Integration**
```python
# Lambda function that works with API Gateway proxy
import json

def lambda_handler(event, context):
    # Access request details
    http_method = event['httpMethod']
    path = event['path']
    query_params = event.get('queryStringParameters', {})
    headers = event.get('headers', {})
    body = json.loads(event.get('body', '{}'))
    
    # Process request
    if http_method == 'GET':
        return {
            'statusCode': 200,
            'headers': {
                'Access-Control-Allow-Origin': '*',
                'Content-Type': 'application/json'
            },
            'body': json.dumps({'message': 'GET request processed'})
        }
    
    elif http_method == 'POST':
        # Process POST data
        return {
            'statusCode': 201,
            'headers': {
                'Access-Control-Allow-Origin': '*',
                'Content-Type': 'application/json'
            },
            'body': json.dumps({
                'message': 'Resource created',
                'data': body
            })
        }
```

**Example 2: Request Validation**
```json
{
  "type": "object",
  "required": ["name", "email"],
  "properties": {
    "name": {
      "type": "string",
      "minLength": 1,
      "maxLength": 100
    },
    "email": {
      "type": "string",
      "format": "email"
    },
    "age": {
      "type": "integer",
      "minimum": 0,
      "maximum": 150
    }
  }
}
```

**Example 3: Custom Authorizer (Lambda Authorizer)**
```python
import json

def lambda_handler(event, context):
    token = event['authorizationToken']
    method_arn = event['methodArn']
    
    # Validate token
    if validate_token(token):
        return generate_policy('user123', 'Allow', method_arn)
    else:
        return generate_policy('user123', 'Deny', method_arn)

def generate_policy(principal_id, effect, resource):
    return {
        'principalId': principal_id,
        'policyDocument': {
            'Version': '2012-10-17',
            'Statement': [{
                'Action': 'execute-api:Invoke',
                'Effect': effect,
                'Resource': resource
            }]
        },
        'context': {
            'userId': principal_id,
            'role': 'admin'
        }
    }

def validate_token(token):
    # Implement your token validation logic
    return token == 'valid-token'
```

**Example 4: Mapping Template (VTL)**
```velocity
## Request mapping template
{
  "userId": "$input.params('userId')",
  "action": "$input.path('$.action')",
  "timestamp": "$context.requestTime",
  "sourceIp": "$context.identity.sourceIp"
}

## Response mapping template
#set($inputRoot = $input.path('$'))
{
  "success": true,
  "data": $inputRoot,
  "requestId": "$context.requestId"
}
```

**API Gateway Features:**

**Caching Configuration:**
```bash
# Enable caching via CLI
aws apigateway update-stage \
    --rest-api-id abc123 \
    --stage-name prod \
    --patch-operations \
        op=replace,path=/cacheClusterEnabled,value=true \
        op=replace,path=/cacheClusterSize,value=0.5

# Cache TTL: 300 seconds (5 minutes) default
```

**Throttling Setup:**
```bash
# Set throttling limits
aws apigateway update-stage \
    --rest-api-id abc123 \
    --stage-name prod \
    --patch-operations \
        op=replace,path=/*/throttle/rateLimit,value=1000 \
        op=replace,path=/*/throttle/burstLimit,value=2000
```

**CORS Configuration:**
```javascript
// Enable CORS in API Gateway
// Response Headers:
{
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Methods": "GET,POST,PUT,DELETE,OPTIONS",
  "Access-Control-Allow-Headers": "Content-Type,X-Amz-Date,Authorization,X-Api-Key"
}
```

**API Gateway Important Limits:**
- Integration timeout: **29 seconds** (hard limit)
- Payload size: 10 MB
- Header size: 10 KB
- Throttle default: 10,000 requests/second
- Burst: 5,000 requests

### 1.3 Amazon DynamoDB
**‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏π‡πâ:**
- Partition key ‡πÅ‡∏•‡∏∞ Sort key
- Read/Write capacity modes (Provisioned vs On-demand)
- Global Secondary Index (GSI) ‡πÅ‡∏•‡∏∞ Local Secondary Index (LSI)
- DynamoDB Streams
- DAX (DynamoDB Accelerator) ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö caching
- Transactions ‡πÅ‡∏•‡∏∞ Batch operations
- TTL (Time To Live)

**‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô:**
```python
import boto3
from boto3.dynamodb.conditions import Key, Attr

dynamodb = boto3.resource('dynamodb')
table = dynamodb.Table('Users')

# Put item
table.put_item(
    Item={
        'userId': '123',
        'name': 'John Doe',
        'email': 'john@example.com',
        'age': 30,
        'status': 'active'
    }
)

# Query with partition key
response = table.query(
    KeyConditionExpression=Key('userId').eq('123')
)

# Query with partition key and sort key
response = table.query(
    KeyConditionExpression=Key('userId').eq('123') & Key('timestamp').gt(1234567890)
)

# Scan with filter
response = table.scan(
    FilterExpression=Attr('age').gte(18) & Attr('status').eq('active')
)

# Update item
table.update_item(
    Key={'userId': '123'},
    UpdateExpression='SET age = :age, #status = :status',
    ExpressionAttributeNames={'#status': 'status'},
    ExpressionAttributeValues={
        ':age': 31,
        ':status': 'premium'
    }
)

# Conditional update
table.update_item(
    Key={'userId': '123'},
    UpdateExpression='SET points = points + :inc',
    ConditionExpression='points < :max',
    ExpressionAttributeValues={
        ':inc': 10,
        ':max': 1000
    }
)

# Batch write (up to 25 items)
with table.batch_writer() as batch:
    for i in range(10):
        batch.put_item(Item={
            'userId': f'user{i}',
            'name': f'User {i}'
        })

# Batch get
response = dynamodb.batch_get_item(
    RequestItems={
        'Users': {
            'Keys': [
                {'userId': '123'},
                {'userId': '456'}
            ]
        }
    }
)

# Transaction (atomic operations)
dynamodb_client = boto3.client('dynamodb')
dynamodb_client.transact_write_items(
    TransactItems=[
        {
            'Put': {
                'TableName': 'Orders',
                'Item': {'orderId': {'S': 'order123'}}
            }
        },
        {
            'Update': {
                'TableName': 'Inventory',
                'Key': {'productId': {'S': 'prod123'}},
                'UpdateExpression': 'SET quantity = quantity - :dec',
                'ExpressionAttributeValues': {':dec': {'N': '1'}}
            }
        }
    ]
)
```

**Advanced DynamoDB Patterns:**

**Pattern 1: One-to-Many Relationship**
```python
# Single table design
# User: PK=USER#123, SK=PROFILE
# Posts: PK=USER#123, SK=POST#20231015#001

table.put_item(Item={
    'PK': 'USER#123',
    'SK': 'PROFILE',
    'name': 'John Doe',
    'email': 'john@example.com'
})

table.put_item(Item={
    'PK': 'USER#123',
    'SK': 'POST#20231015#001',
    'title': 'My First Post',
    'content': 'Hello World'
})

# Query all items for a user
response = table.query(
    KeyConditionExpression=Key('PK').eq('USER#123')
)
```

**Pattern 2: Global Secondary Index (GSI)**
```python
# Table: PK=userId, SK=timestamp
# GSI: PK=status, SK=timestamp (to query by status)

# Query active users sorted by timestamp
response = table.query(
    IndexName='StatusTimestampIndex',
    KeyConditionExpression=Key('status').eq('active')
)
```

**Pattern 3: Optimistic Locking**
```python
# Use version number for concurrency control
try:
    table.update_item(
        Key={'userId': '123'},
        UpdateExpression='SET balance = :newBalance, version = version + :inc',
        ConditionExpression='version = :currentVersion',
        ExpressionAttributeValues={
            ':newBalance': 1000,
            ':currentVersion': 5,
            ':inc': 1
        }
    )
except ClientError as e:
    if e.response['Error']['Code'] == 'ConditionalCheckFailedException':
        print('Version mismatch - retry')
```

**DynamoDB Performance Tips:**
1. **Hot Partitions**: Distribute data evenly across partition keys
2. **Batch Operations**: Use batch_get_item ‡πÅ‡∏•‡∏∞ batch_write_item
3. **Projection**: Request only needed attributes
4. **Consistent Reads**: Use only when needed (costs 2x)
5. **Auto Scaling**: Enable for variable workloads
6. **DAX**: Use for read-heavy, low-latency requirements

### 1.4 Amazon S3
**‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏π‡πâ:**
- S3 storage classes (Standard, IA, Glacier, etc.)
- Versioning ‡πÅ‡∏•‡∏∞ Lifecycle policies
- S3 Event Notifications
- S3 Transfer Acceleration
- Multipart upload ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏Ç‡∏ô‡∏≤‡∏î‡πÉ‡∏´‡∏ç‡πà
- Pre-signed URLs
- CORS configuration

**Storage Classes:**
- **S3 Standard:** ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á‡∏ö‡πà‡∏≠‡∏¢
- **S3 Standard-IA:** ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á‡πÑ‡∏°‡πà‡∏ö‡πà‡∏≠‡∏¢
- **S3 One Zone-IA:** ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç, AZ ‡πÄ‡∏î‡∏µ‡∏¢‡∏ß
- **S3 Glacier:** Archive ‡∏£‡∏∞‡∏¢‡∏∞‡∏¢‡∏≤‡∏ß
- **S3 Glacier Deep Archive:** Archive ‡∏ó‡∏µ‡πà‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á‡∏ô‡πâ‡∏≠‡∏¢‡∏°‡∏≤‡∏Å

### 1.5 Amazon SQS (Simple Queue Service)
**‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏π‡πâ:**
- Standard Queue vs FIFO Queue
- Message visibility timeout
- Dead Letter Queue (DLQ)
- Long polling vs Short polling
- Message retention period (1 ‡∏ô‡∏≤‡∏ó‡∏µ - 14 ‡∏ß‡∏±‡∏ô)
- Maximum message size: 256 KB

**‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô:**
```python
import boto3

sqs = boto3.client('sqs')

# Send message
response = sqs.send_message(
    QueueUrl='queue-url',
    MessageBody='Hello World'
)

# Receive message
messages = sqs.receive_message(
    QueueUrl='queue-url',
    MaxNumberOfMessages=10,
    WaitTimeSeconds=20  # Long polling
)
```

### 1.6 Amazon SNS (Simple Notification Service)
**‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏π‡πâ:**
- Topics ‡πÅ‡∏•‡∏∞ Subscriptions
- Message filtering
- Fan-out pattern (SNS + SQS)
- SMS, Email, HTTP/HTTPS endpoints
- Mobile push notifications

### 1.7 Amazon Kinesis
**‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏π‡πâ:**
- Kinesis Data Streams
- Kinesis Data Firehose
- Kinesis Data Analytics
- Shards ‡πÅ‡∏•‡∏∞ Partition keys
- Data retention (1-365 ‡∏ß‡∏±‡∏ô)

### 1.8 AWS Step Functions
**‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏π‡πâ:**
- State machines ‡πÅ‡∏•‡∏∞ States
- Task, Choice, Parallel, Wait, Fail, Succeed states
- Error handling ‡πÅ‡∏•‡∏∞ Retry logic
- Integration ‡∏Å‡∏±‡∏ö AWS services

### 1.9 Amazon ElastiCache
**‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏π‡πâ:**
- Redis vs Memcached
- Cache strategies: Lazy loading, Write-through
- TTL (Time To Live)
- Cluster mode

### 1.10 AWS X-Ray
**‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏π‡πâ:**
- Distributed tracing
- Service map
- Segments ‡πÅ‡∏•‡∏∞ Subsegments
- Annotations ‡πÅ‡∏•‡∏∞ Metadata
- Sampling rules

**‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô X-Ray:**
```python
from aws_xray_sdk.core import xray_recorder
from aws_xray_sdk.core import patch_all
import boto3

# Patch all AWS SDK calls
patch_all()

dynamodb = boto3.resource('dynamodb')

@xray_recorder.capture('process_order')
def process_order(order_id):
    # Add annotations (indexed, searchable)
    xray_recorder.put_annotation('orderId', order_id)
    xray_recorder.put_annotation('orderType', 'premium')
    
    # Add metadata (not indexed, more details)
    xray_recorder.put_metadata('orderDetails', {
        'items': 5,
        'total': 99.99
    })
    
    # Your business logic
    table = dynamodb.Table('Orders')
    table.put_item(Item={'orderId': order_id})
    
    return {'status': 'success'}
```

**Real-world Example:**
‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏°‡∏µ request ‡∏ä‡πâ‡∏≤ ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ä‡πâ X-Ray ‡∏î‡∏π:
- ‡∏™‡πà‡∏ß‡∏ô‡πÑ‡∏´‡∏ô‡∏Ç‡∏≠‡∏á application ‡πÉ‡∏ä‡πâ‡πÄ‡∏ß‡∏•‡∏≤‡∏ô‡∏≤‡∏ô
- ‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏Å AWS services ‡πÉ‡∏î ‡∏ä‡πâ‡∏≤
- Database queries ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ optimization

---

## üèóÔ∏è Architecture Patterns

### Pattern 1: Serverless Web Application
**Use Case:** Web application ‡∏ó‡∏µ‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö traffic ‡πÑ‡∏°‡πà‡πÅ‡∏ô‡πà‡∏ô‡∏≠‡∏ô

```
CloudFront (CDN)
    ‚Üì
S3 (Static Content: HTML/CSS/JS)
    ‚Üì
API Gateway
    ‚Üì
Lambda Functions
    ‚Üì
DynamoDB / RDS

Benefits:
‚úÖ Auto-scaling
‚úÖ Pay per use
‚úÖ No server management
‚úÖ High availability
```

### Pattern 2: Event-Driven Architecture
**Use Case:** ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà upload ‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤

```
S3 Bucket
    ‚Üì (S3 Event Notification)
Lambda Function 1 (Validation)
    ‚Üì
SQS Queue
    ‚Üì
Lambda Function 2 (Processing)
    ‚Üì
DynamoDB (Store Results)
    ‚Üì
SNS (Notify Users)

Benefits:
‚úÖ Asynchronous processing
‚úÖ Decoupled components
‚úÖ Error handling with DLQ
‚úÖ Scalable
```

### Pattern 3: Microservices with Containers
**Use Case:** ‡πÅ‡∏≠‡∏û‡∏û‡∏•‡∏¥‡πÄ‡∏Ñ‡∏ä‡∏±‡πà‡∏ô‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏´‡∏•‡∏≤‡∏¢ services

```
Application Load Balancer
    ‚Üì
ECS/Fargate Services
    ‚îú‚îÄ‚îÄ User Service
    ‚îú‚îÄ‚îÄ Product Service
    ‚îú‚îÄ‚îÄ Order Service
    ‚îî‚îÄ‚îÄ Payment Service
    ‚Üì
RDS / DynamoDB

Benefits:
‚úÖ Service isolation
‚úÖ Independent deployment
‚úÖ Technology flexibility
‚úÖ Easy scaling
```

### Pattern 4: Fan-out Pattern
**Use Case:** ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÑ‡∏õ‡∏´‡∏•‡∏≤‡∏¢ destinations

```
API Gateway
    ‚Üì
Lambda (Publisher)
    ‚Üì
SNS Topic
    ‚îú‚îÄ‚îÄ SQS Queue 1 ‚Üí Lambda (Email Service)
    ‚îú‚îÄ‚îÄ SQS Queue 2 ‚Üí Lambda (SMS Service)
    ‚îî‚îÄ‚îÄ SQS Queue 3 ‚Üí Lambda (Push Notification)

Benefits:
‚úÖ Parallel processing
‚úÖ Independent failure
‚úÖ Easy to add new subscribers
```

---

## 2. Security

### 2.1 AWS IAM (Identity and Access Management)
**‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏π‡πâ:**
- Users, Groups, Roles, ‡πÅ‡∏•‡∏∞ Policies
- Policy types: Identity-based, Resource-based, SCPs
- Permission boundaries
- IAM roles ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö EC2, Lambda
- AssumeRole ‡πÅ‡∏•‡∏∞ Cross-account access
- MFA (Multi-Factor Authentication)

**Policy ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á:**
```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "s3:GetObject",
        "s3:PutObject"
      ],
      "Resource": "arn:aws:s3:::my-bucket/*"
    }
  ]
}
```

### 2.2 AWS KMS (Key Management Service)
**‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏π‡πâ:**
- Customer Master Keys (CMK)
- Envelope encryption
- Key rotation
- Grant-based access control
- Integration ‡∏Å‡∏±‡∏ö S3, EBS, RDS

### 2.3 AWS Secrets Manager
**‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏π‡πâ:**
- ‡∏à‡∏±‡∏î‡πÄ‡∏Å‡πá‡∏ö‡πÅ‡∏•‡∏∞ rotate secrets
- Integration ‡∏Å‡∏±‡∏ö RDS
- Automatic rotation
- Version management

**‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á:**
```python
import boto3
import json

client = boto3.client('secretsmanager')

# Get secret
response = client.get_secret_value(SecretId='MySecret')
secret = json.loads(response['SecretString'])
```

### 2.4 AWS Systems Manager Parameter Store
**‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏π‡πâ:**
- String, StringList, SecureString parameters
- Hierarchical parameters
- Parameter policies
- Integration ‡∏Å‡∏±‡∏ö CloudFormation

### 2.5 Amazon Cognito
**‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏π‡πâ:**
- User Pools ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö authentication
- Identity Pools ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö AWS credentials
- Social identity providers (Facebook, Google)
- SAML integration
- JWT tokens

### 2.6 Security Best Practices
- **Principle of Least Privilege:** ‡πÉ‡∏´‡πâ‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡πÅ‡∏Ñ‡πà‡∏ó‡∏µ‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô
- **Encryption at rest ‡πÅ‡∏•‡∏∞ in transit**
- ‡πÉ‡∏ä‡πâ IAM roles ‡πÅ‡∏ó‡∏ô access keys
- Enable MFA ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö privileged users
- Regular security audits ‡∏î‡πâ‡∏ß‡∏¢ AWS Config, CloudTrail
- Implement VPC security groups ‡πÅ‡∏•‡∏∞ NACLs

---

## 3. Deployment

### 3.1 AWS Elastic Beanstalk
**‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏π‡πâ:**
- Application versions ‡πÅ‡∏•‡∏∞ Environments
- Deployment policies:
  - All at once
  - Rolling
  - Rolling with additional batch
  - Immutable
  - Blue/Green
- .ebextensions configuration
- Environment tiers: Web server, Worker

### 3.2 AWS CloudFormation
**‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏π‡πâ:**
- Templates (JSON/YAML)
- Stacks ‡πÅ‡∏•‡∏∞ StackSets
- Parameters, Mappings, Conditions, Outputs
- Intrinsic functions (Ref, GetAtt, Join, Sub)
- Change sets
- Stack policies
- Nested stacks

**Template ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á:**
```yaml
AWSTemplateFormatVersion: '2010-09-09'
Resources:
  MyBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: my-unique-bucket
      VersioningConfiguration:
        Status: Enabled
```

### 3.3 AWS SAM (Serverless Application Model)
**‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏π‡πâ:**
- SAM template syntax
- SAM CLI commands (build, deploy, local)
- Local testing ‡∏î‡πâ‡∏ß‡∏¢ sam local
- Transform: AWS::Serverless-2016-10-31

### 3.4 AWS CodeCommit
**‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏π‡πâ:**
- Git-based repository
- Branches ‡πÅ‡∏•‡∏∞ Pull requests
- Triggers ‡πÅ‡∏•‡∏∞ Notifications
- Integration ‡∏Å‡∏±‡∏ö CodePipeline

### 3.5 AWS CodeBuild
**‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏π‡πâ:**
- buildspec.yml configuration
- Build phases: install, pre_build, build, post_build
- Environment variables
- Artifacts ‡πÅ‡∏•‡∏∞ Cache
- Integration ‡∏Å‡∏±‡∏ö CodePipeline

**buildspec.yml ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á:**
```yaml
version: 0.2
phases:
  install:
    runtime-versions:
      nodejs: 14
  pre_build:
    commands:
      - npm install
  build:
    commands:
      - npm run build
artifacts:
  files:
    - '**/*'
```

### 3.6 AWS CodeDeploy
**‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏π‡πâ:**
- Deployment groups ‡πÅ‡∏•‡∏∞ Application
- Deployment types:
  - In-place
  - Blue/Green
- appspec.yml configuration
- Deployment configurations
- Rollback mechanisms

### 3.7 AWS CodePipeline
**‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏π‡πâ:**
- Pipeline stages ‡πÅ‡∏•‡∏∞ Actions
- Source, Build, Deploy stages
- Manual approval actions
- Integration ‡∏Å‡∏±‡∏ö CodeCommit, CodeBuild, CodeDeploy

### 3.8 Amazon ECS/EKS
**‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏π‡πâ:**
- Task definitions ‡πÅ‡∏•‡∏∞ Services
- Fargate vs EC2 launch types
- Service discovery
- Load balancing
- Auto scaling

### 3.9 AWS Lambda Deployment
**‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏π‡πâ:**
- Versions ‡πÅ‡∏•‡∏∞ Aliases
- Deployment preferences (Linear, Canary, All-at-once)
- Environment variables
- Layers
- Container image support

---

## 4. Troubleshooting and Optimization

### 4.1 Amazon CloudWatch
**‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏π‡πâ:**
- Metrics, Alarms, ‡πÅ‡∏•‡∏∞ Dashboards
- CloudWatch Logs ‡πÅ‡∏•‡∏∞ Log groups
- CloudWatch Events/EventBridge
- CloudWatch Logs Insights
- Custom metrics
- Log retention policies

**Custom Metric ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á:**
```python
import boto3

cloudwatch = boto3.client('cloudwatch')

cloudwatch.put_metric_data(
    Namespace='MyApp',
    MetricData=[
        {
            'MetricName': 'ProcessedItems',
            'Value': 123,
            'Unit': 'Count'
        }
    ]
)
```

### 4.2 AWS CloudTrail
**‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏π‡πâ:**
- API call logging
- Management events vs Data events
- Multi-region trails
- Log file integrity validation
- Integration ‡∏Å‡∏±‡∏ö CloudWatch Logs

### 4.3 Performance Optimization
**Lambda Optimization:**
- ‡πÄ‡∏û‡∏¥‡πà‡∏° memory ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏û‡∏¥‡πà‡∏° CPU
- ‡πÉ‡∏ä‡πâ Lambda layers ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö dependencies
- Minimize cold starts
- Connection pooling ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö database
- Asynchronous processing

**DynamoDB Optimization:**
- ‡∏≠‡∏≠‡∏Å‡πÅ‡∏ö‡∏ö partition key ‡πÉ‡∏´‡πâ‡∏î‡∏µ
- ‡πÉ‡∏ä‡πâ GSI/LSI ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏°‡∏µ‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û
- Enable auto-scaling
- ‡πÉ‡∏ä‡πâ DAX ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö read-heavy workloads
- Batch operations

**API Gateway Optimization:**
- Enable caching
- Use compression
- Implement throttling
- Minimize payload size

### 4.4 Cost Optimization
- ‡πÉ‡∏ä‡πâ reserved capacity ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö predictable workloads
- Enable auto-scaling
- Use appropriate storage classes
- Monitor ‡πÅ‡∏•‡∏∞ analyze costs ‡∏î‡πâ‡∏ß‡∏¢ Cost Explorer
- Set up billing alarms

### 4.5 Common Issues ‡πÅ‡∏•‡∏∞ Solutions

**Lambda Timeout:**
- ‡πÄ‡∏û‡∏¥‡πà‡∏° timeout setting
- Optimize code performance
- ‡πÉ‡∏ä‡πâ async processing ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö long-running tasks

**DynamoDB Throttling:**
- ‡πÄ‡∏û‡∏¥‡πà‡∏° read/write capacity
- ‡πÉ‡∏ä‡πâ exponential backoff
- Distribute load across partition keys
- Consider on-demand pricing

**API Gateway 5xx Errors:**
- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö backend integration
- Review Lambda permissions
- Check CloudWatch Logs
- Verify timeout settings

**Real-world Troubleshooting Scenarios:**

**Scenario 1: Lambda Cold Start Issues**
```python
# Problem: Function experiences 3-5 second delays on first invocation

# Solution 1: Use Provisioned Concurrency
aws lambda put-provisioned-concurrency-config \
    --function-name MyFunction \
    --provisioned-concurrent-executions 5 \
    --qualifier PROD

# Solution 2: Keep functions warm with CloudWatch Events
# Create a rule to invoke Lambda every 5 minutes

# Solution 3: Optimize package size
# - Remove unused dependencies
# - Use Lambda Layers for common libraries
# - Minimize deployment package

# Solution 4: Increase memory (gives more CPU)
aws lambda update-function-configuration \
    --function-name MyFunction \
    --memory-size 1024  # From 128 MB
```

**Scenario 2: DynamoDB Hot Partition**
```python
# Problem: High latency and throttling on specific items

# Diagnosis:
# Check CloudWatch metrics for:
# - UserErrors (throttling)
# - SystemErrors
# - ConsumedReadCapacityUnits by table

# Solution 1: Better partition key design
# Bad: date as partition key (all today's data in one partition)
# Good: userId or composite key

# Before (Hot Partition):
PK = "2023-10-15"  # All today's data
SK = "order-123"

# After (Distributed):
PK = "user-123"  # Distributed across users
SK = "2023-10-15#order-123"

# Solution 2: Use write sharding for time-series data
import random

def get_partition_key(date):
    shard = random.randint(0, 9)  # 10 shards
    return f"{date}#{shard}"

# Now data is distributed across 10 partitions
PK = "2023-10-15#3"
```

**Scenario 3: API Gateway 502 Bad Gateway**
```python
# Problem: Intermittent 502 errors

# Common Causes:
# 1. Lambda function error/timeout
# 2. Lambda returning invalid response format
# 3. VPC configuration issues

# Diagnosis:
# Check CloudWatch Logs for Lambda

# Solution 1: Fix Lambda response format
# Wrong:
def lambda_handler(event, context):
    return "success"  # Invalid!

# Correct:
def lambda_handler(event, context):
    return {
        'statusCode': 200,
        'body': json.dumps({'message': 'success'})
    }

# Solution 2: Handle Lambda errors gracefully
def lambda_handler(event, context):
    try:
        result = process_data(event)
        return {
            'statusCode': 200,
            'body': json.dumps(result)
        }
    except Exception as e:
        print(f"Error: {str(e)}")  # CloudWatch Logs
        return {
            'statusCode': 500,
            'body': json.dumps({'error': 'Internal error'})
        }
```

**Scenario 4: High AWS Costs**
```python
# Problem: Unexpected high bill

# Diagnosis Steps:
# 1. Use Cost Explorer to identify service costs
aws ce get-cost-and-usage \
    --time-period Start=2023-10-01,End=2023-10-31 \
    --granularity DAILY \
    --metrics BlendedCost

# 2. Check for:
# - NAT Gateway data transfer
# - CloudWatch Logs retention
# - DynamoDB on-demand costs
# - Lambda invocations/duration

# Solutions:
# 1. Set up billing alarms
aws cloudwatch put-metric-alarm \
    --alarm-name BillingAlarm \
    --alarm-description "Alert when cost exceeds $50" \
    --metric-name EstimatedCharges \
    --namespace AWS/Billing \
    --statistic Maximum \
    --period 21600 \
    --threshold 50 \
    --comparison-operator GreaterThanThreshold

# 2. Clean up unused resources
# - Delete old CloudWatch Log groups
# - Remove unused DynamoDB tables
# - Delete old Lambda versions
# - Stop unused EC2 instances

# 3. Optimize Lambda
# - Right-size memory
# - Reduce execution time
# - Use reserved concurrency wisely

# 4. Optimize DynamoDB
# - Switch to on-demand if usage is unpredictable
# - Use DAX for read-heavy workloads
# - Archive old data to S3
```

**Scenario 5: SQS Message Processing Delays**
```python
# Problem: Messages sitting in queue for too long

# Diagnosis:
# Check CloudWatch metrics:
# - ApproximateAgeOfOldestMessage
# - ApproximateNumberOfMessagesVisible

# Common Issues:

# Issue 1: Low concurrent executions
# Solution: Increase reserved concurrency
aws lambda put-function-concurrency \
    --function-name MyConsumer \
    --reserved-concurrent-executions 100

# Issue 2: Visibility timeout too short
# Solution: Increase visibility timeout
aws sqs set-queue-attributes \
    --queue-url $QUEUE_URL \
    --attributes VisibilityTimeout=300  # 5 minutes

# Issue 3: Processing errors causing redelivery
# Solution: Implement DLQ and error handling
def lambda_handler(event, context):
    for record in event['Records']:
        try:
            process_message(record)
        except Exception as e:
            # Log error for debugging
            print(f"Error: {str(e)}")
            print(f"Message: {record['body']}")
            # Re-raise to send to DLQ after max retries
            raise

# Issue 4: Batch size too large
# Solution: Reduce batch size
aws lambda update-event-source-mapping \
    --uuid $MAPPING_UUID \
    --batch-size 5  # From 10
```

**Scenario 6: CloudWatch Logs Too Expensive**
```python
# Problem: High CloudWatch Logs costs

# Solutions:

# 1. Adjust retention period
aws logs put-retention-policy \
    --log-group-name /aws/lambda/MyFunction \
    --retention-in-days 7  # Instead of indefinite

# 2. Filter what gets logged
import logging
logger = logging.getLogger()
logger.setLevel(logging.WARNING)  # Only WARN and ERROR

# 3. Use sampling for high-volume logs
import random

def lambda_handler(event, context):
    # Log only 10% of requests
    if random.random() < 0.1:
        print(f"Detailed log: {event}")
    
    # Always log errors
    try:
        process(event)
    except Exception as e:
        print(f"ERROR: {str(e)}")
        raise

# 4. Export old logs to S3
aws logs create-export-task \
    --log-group-name /aws/lambda/MyFunction \
    --from 1633046400000 \
    --to 1635724800000 \
    --destination my-logs-bucket \
    --destination-prefix lambda-logs/
```

**Debugging Tools & Commands:**

```bash
# View Lambda logs
aws logs tail /aws/lambda/MyFunction --follow

# Test Lambda locally with SAM
sam local invoke MyFunction -e events/event.json

# View X-Ray traces
aws xray get-trace-summaries \
    --start-time 2023-10-15T00:00:00 \
    --end-time 2023-10-15T23:59:59

# Check DynamoDB table metrics
aws cloudwatch get-metric-statistics \
    --namespace AWS/DynamoDB \
    --metric-name ConsumedReadCapacityUnits \
    --dimensions Name=TableName,Value=MyTable \
    --start-time 2023-10-15T00:00:00Z \
    --end-time 2023-10-15T23:59:59Z \
    --period 3600 \
    --statistics Sum

# Check API Gateway metrics
aws cloudwatch get-metric-statistics \
    --namespace AWS/ApiGateway \
    --metric-name 5XXError \
    --dimensions Name=ApiName,Value=MyAPI \
    --start-time 2023-10-15T00:00:00Z \
    --end-time 2023-10-15T23:59:59Z \
    --period 300 \
    --statistics Sum
```

---

## Additional Resources

### ‡∏´‡∏ô‡∏±‡∏á‡∏™‡∏∑‡∏≠‡πÅ‡∏•‡∏∞‡∏Ñ‡∏≠‡∏£‡πå‡∏™‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥
1. **AWS Official Documentation:** https://docs.aws.amazon.com
2. **AWS Training and Certification:** https://aws.amazon.com/training
3. **A Cloud Guru:** AWS Certified Developer Associate course
4. **Udemy:** Stephane Maarek's AWS courses
5. **Linux Academy/ACG:** Developer Associate learning path

### Hands-on Practice
1. **AWS Free Tier:** https://aws.amazon.com/free
2. **AWS Workshops:** https://workshops.aws
3. **AWS Well-Architected Labs:** https://wellarchitectedlabs.com
4. **Qwiklabs:** AWS quest ‡πÅ‡∏•‡∏∞ labs

### ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏ó‡∏µ‡πà‡∏Ñ‡∏ß‡∏£‡∏£‡∏π‡πâ‡∏à‡∏±‡∏Å
- **AWS CLI:** Command line interface
- **AWS SDKs:** Python (Boto3), JavaScript, Java, .NET
- **AWS SAM CLI:** Local testing serverless applications
- **AWS CDK:** Infrastructure as Code ‡∏î‡πâ‡∏ß‡∏¢ programming languages

---

## Exam Tips

### ‡πÄ‡∏ó‡∏Ñ‡∏ô‡∏¥‡∏Ñ‡∏Å‡∏≤‡∏£‡∏™‡∏≠‡∏ö
1. **‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡πÉ‡∏´‡πâ‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î** - ‡∏°‡∏±‡∏Å‡∏°‡∏µ‡∏Ñ‡∏µ‡∏¢‡πå‡πÄ‡∏ß‡∏¥‡∏£‡πå‡∏î‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç ‡πÄ‡∏ä‡πà‡∏ô "most cost-effective", "least operational overhead"
2. **Eliminate wrong answers** - ‡∏ï‡∏±‡∏î‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ó‡∏µ‡πà‡∏ú‡∏¥‡∏î‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô‡∏≠‡∏≠‡∏Å‡∏Å‡πà‡∏≠‡∏ô
3. **Time management** - ‡∏≠‡∏¢‡πà‡∏≤‡πÉ‡∏ä‡πâ‡πÄ‡∏ß‡∏•‡∏≤‡∏Å‡∏±‡∏ö‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡∏¢‡∏≤‡∏Å‡πÄ‡∏Å‡∏¥‡∏ô 2-3 ‡∏ô‡∏≤‡∏ó‡∏µ
4. **Flag ‡πÅ‡∏•‡∏∞ review** - ‡∏ó‡∏≥‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏°‡∏≤‡∏¢‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÅ‡∏ô‡πà‡πÉ‡∏à‡πÑ‡∏ß‡πâ review ‡∏ó‡∏µ‡∏´‡∏•‡∏±‡∏á
5. **‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏î‡∏≤** - ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏´‡∏±‡∏Å‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô ‡πÉ‡∏´‡πâ‡πÄ‡∏î‡∏≤‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏£‡∏π‡πâ‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö

### ‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏û‡∏ö‡∏ö‡πà‡∏≠‡∏¢ (Frequently Asked Topics)
- Lambda + API Gateway + DynamoDB architecture
- S3 versioning ‡πÅ‡∏•‡∏∞ lifecycle policies
- IAM roles ‡πÅ‡∏•‡∏∞ policies
- CloudFormation intrinsic functions
- CI/CD pipeline ‡∏î‡πâ‡∏ß‡∏¢ CodePipeline
- DynamoDB partition key design
- API Gateway caching ‡πÅ‡∏•‡∏∞ throttling
- Lambda environment variables ‡πÅ‡∏•‡∏∞ layers
- CloudWatch metrics ‡πÅ‡∏•‡∏∞ alarms
- X-Ray tracing

### ‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà‡∏Ñ‡∏ß‡∏£‡∏à‡∏≥
- **Lambda limits:** 15 ‡∏ô‡∏≤‡∏ó‡∏µ timeout, 10 GB memory
- **API Gateway timeout:** 29 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
- **SQS message retention:** 1 ‡∏ô‡∏≤‡∏ó‡∏µ - 14 ‡∏ß‡∏±‡∏ô
- **SQS message size:** 256 KB
- **DynamoDB item size:** 400 KB
- **S3 object size:** 0 bytes - 5 TB
- **CloudFormation template size:** 51,200 bytes (body), 460,800 bytes (S3)

### ‡∏™‡∏π‡∏ï‡∏£‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à
1. ‚úÖ ‡∏ó‡∏≥ hands-on labs ‡∏ö‡πà‡∏≠‡∏¢‡πÜ
2. ‚úÖ ‡∏≠‡πà‡∏≤‡∏ô AWS documentation
3. ‚úÖ ‡∏ó‡∏≥ practice exams
4. ‚úÖ ‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à use cases ‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞ service
5. ‚úÖ ‡∏£‡∏π‡πâ limitations ‡πÅ‡∏•‡∏∞ best practices
6. ‚úÖ ‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à cost optimization strategies

---

## Quick Reference Cards

### Lambda
- Timeout: 1 sec - 15 min
- Memory: 128 MB - 10 GB
- Deployment package: 50 MB (zipped), 250 MB (unzipped)
- Environment variables: 4 KB
- Concurrent executions: 1000 (default)

### DynamoDB
- Item size: 400 KB
- Partition key: required
- Sort key: optional
- GSI: 20 per table
- LSI: 5 per table

### S3
- Object size: 5 TB
- Multipart upload: > 100 MB recommended
- Single PUT: 5 GB max
- Buckets per account: 100 (soft limit)

### API Gateway
- Integration timeout: 29 seconds
- Payload size: 10 MB
- Throttle rate: 10,000 requests/second

---

## Conclusion

‡∏Å‡∏≤‡∏£‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏™‡∏≠‡∏ö AWS Certified Developer - Associate ‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ‡∏ó‡∏±‡πâ‡∏á‡∏Ñ‡∏ß‡∏≤‡∏°‡∏£‡∏π‡πâ‡∏ó‡∏≤‡∏á‡∏ó‡∏§‡∏©‡∏é‡∏µ‡πÅ‡∏•‡∏∞‡∏õ‡∏£‡∏∞‡∏™‡∏ö‡∏Å‡∏≤‡∏£‡∏ì‡πå‡∏à‡∏£‡∏¥‡∏á ‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡πÉ‡∏´‡πâ:

1. **Study AWS documentation** ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î
2. **Hands-on practice** ‡∏Å‡∏±‡∏ö AWS services ‡∏ó‡∏µ‡πà‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç
3. **‡∏ó‡∏≥ practice exams** ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏£‡∏π‡πâ
4. **‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à scenarios** ‡πÅ‡∏•‡∏∞ use cases
5. **Review ‡∏Å‡πà‡∏≠‡∏ô‡∏™‡∏≠‡∏ö** ‡∏™‡∏°‡πà‡∏≥‡πÄ‡∏™‡∏°‡∏≠

**Good luck ‡∏Å‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏™‡∏≠‡∏ö! üéâ**

---

*Last Updated: October 2025*
*Version: 1.0*